language NamedLet {


  (* Functions *)
  
  (Lambda param body) {
    import 1;
    import 2;
    bind 1 in 2;
  }
  (Param name params) {
    import 1;
    import 2;
    export 1;
    export 2;
    bind 1 in 2; (* ! *)
    bind 2 in 1;
  }
  (End) {}
  
  (Apply func args) {
    import 1;
    import 2;
  }
  (Arg arg args) {
    import 1;
    import 2;
  }


  (* Multiple bodies *)

  (Void) {}
  (Begin expr rest) {
    import 1;
    import 2;
  }


  (* Regular (parallel) Let *)
  
  (Let binds body) {
    import 1;
    import 2;
    bind 1 in 2;
  }
  (LetBind name defn binds) {
    import 1;
    import 2;
    import 3;
    export 1;
    export 3;
    bind 1 in 3;
    bind 3 in 1;
  }
  
  (Set var defn stmts) {
    import 1;
    import 2;
    import 3;
    export 3;
  }


  (* Conditionals *)

  (If cond consq altern) {
    import 1;
    import 2;
    import 3;
  }
  

  (* Sugars *)

  sugar (Letstar binds body)
  sugar (LetstarBind var init binds)

  sugar (Letrec binds body)
  sugar (LetrecBind var init binds)

  sugar (Do binds test body)
  sugar (DoBindStep var init step binds)
  sugar (DoBind var init binds)  (* If 'step...' is empty *)
  sugar (DoTest test expr)


  (* Letstar *)

  rule (Letstar (End) body)
    => (Let (End) body)

  rule (Letstar (LetstarBind id init binds) body)
    => (Let (LetBind id init (end))
         (Letstar binds body))

  (* Letrec *)

  rule (Letrec binds body)
    => (DesugarLetrec (ReverseLetrecBinds binds (End)) (End) (End) body)

  (* One or more bindings *)
  rule (DesugarLetrec (End) (LetBind a b undef_binds) (LetBind c d init_binds) body)
    => (Let (LetBind a b undef_binds) (Let (LetBind c d init_binds) body))

  (* No bindings *)
  rule (DesugarLetrec (End) (End) (End) body)
    => (Let (End) (Let (End) body))

  rule (DesugarLetrec
         (LetrecBind var init binds)
         undef_binds
         init_binds
         body)
    => (DesugarLetrec
         binds
         (LetBind var (Void) undef_binds)
         (LetBind @x init init_binds)
         (Set as_refn$var $x body))

  rule (ReverseLetrecBinds (End) (End))
    => (End)

  rule (ReverseLetrecBinds (End) (LetrecBind id init binds))
    => (LetrecBind id init binds)

  rule (ReverseLetrecBinds (LetrecBind id init binds) reversed)
    => (ReverseLetrecBinds binds (LetrecBind id init reversed))


  (* Sanity Check: Make sure that Letrec has the same binding
     weather it's desugared in general (above), or for the specific
     case of two bindings (below). *)

  rule (Letrec (LetrecBind x a (LetrecBind y b (End))) body)
    => (Let (LetBind x (Void) (LetBind y (Void) (End)))
         (Let (LetBind @alpha a (LetBind @beta b (End)))
           (Set as_refn$x $alpha (Set as_refn$y $beta body))))



  (* Do *)

(* The obvious desugaring doesn't work, and infers (among other things)
   that the variables are bound in the `init` expressions. *)

(*
  rule (Do binds test commands)
    => (DesugarDo binds test commands (End) (End) (End))

  rule (DesugarDo (DoBind var init binds) test commands inits vars steps)
    => (DesugarDo binds test commands
         (AppendArg init inits)
         (AppendParam var vars)
         (AppendArg as_refn$var steps))

  rule (DesugarDo (DoBindStep var init step binds) test commands inits vars steps)
    => (DesugarDo binds test commands
         (AppendArg init inits)
         (AppendParam var vars)
         (AppendArg step steps))

  rule (DesugarDo (End) (DoTest test exprs) commands (Arg a inits) (Param b vars) (Arg c steps))
    => (Letrec (Bindrec @loop
         (Lambda (Param b vars)
           (If test
             (Begin (Void) exprs)
             (Begin commands (Apply $loop (Arg c steps))))))
         (Apply $loop (Arg a inits)))
*)


  (* Helpers *)
  
  rule (AppendParam param (End))
    => (Param param (End))

  rule (AppendParam new_param (Param param params))
    => (Param param (AppendParam new_param params))

  rule (AppendArg arg (End))
    => (Arg arg (End))

  rule (AppendArg new_arg (Arg arg args))
    => (Arg arg (AppendArg new_arg args))

}
