language R5RS {


  (* Functions *)
  
  (Lambda param body) {
    import 1;
    import 2;
    bind 1 in 2;
  }
  (Param name params) {
    import 1;
    import 2;
    export 1;
    export 2;
  }
  (End) {}
  
  (Apply func args) {
    import 1;
    import 2;
  }
  (Arg arg args) {
    import 1;
    import 2;
  }


  (* Multiple bodies *)

  (Void) {}
  (Begin expr rest) {
    import 1;
    import 2;
  }


  (* Regular (parallel) Let *)

  (* `bind 1 in 3` and `bind 3 in 1` needed to infer scope for letrec. *)
  (* (letrec needs a preorder; `let` otherwise gives a partial order.)  *)
  (LetBind name defn binds) {
    import 1;
    import 2;
    import 3;
    export 1;
    export 3;
    bind 1 in 3;
    bind 3 in 1;
  }
  
  (Set var defn stmts) {
    import 1;
    import 2;
    import 3;
    export 3;
  }


  (* Conditionals *)

  (If cond consq altern) {
    import 1;
    import 2;
    import 3;
  }


  (* Sugars *)

  sugar (Let binds body)
  sugar (Bind var init binds)

  sugar (Letstar binds body)
  sugar (LetstarBind var init binds)

  sugar (Letrec binds body)
  sugar (LetrecBind var init binds)

  sugar (NamedLet proc_id binds body)
  sugar (NamedLetBind arg_id init_expr binds)

(*
  sugar (Do binds test body)
  sugar (DoBindStep var init step binds)
  sugar (DoBind var init binds)
  sugar (DoTest test expr)
*)


  (* Letstar *)

  rule (Letstar (End) body)
    => (Let (End) body)

  rule (Letstar (LetstarBind id init binds) body)
    => (Let (LetBind id init (end))
         (Letstar binds body))

  (* Letrec *)

  (* One or more bindings *)
  rule (Letrec (LetrecBind var init binds) body)
    => (DesugarLetrec (ReverseLetrecBinds (LetrecBind var init binds) (End)) (End) (End) body)

  (* No bindings *)
  rule (Letrec (End) body)
    => (DesugarLetrec (ReverseLetrecBinds (End) (End)) (End) (End) body)

  (* One or more bindings *)
  rule (DesugarLetrec (End) (LetBind a b undef_binds) (LetBind c d init_binds) body)
    => (Let (LetBind a b undef_binds) (Let (LetBind c d init_binds) body))

  (* No bindings *)
  rule (DesugarLetrec (End) (End) (End) body)
    => (Let (End) (Let (End) body))

  rule (DesugarLetrec
         (LetrecBind var init binds)
         undef_binds
         init_binds
         body)
    => (DesugarLetrec
         binds
         (LetBind var (Void) undef_binds)
         (LetBind @x init init_binds)
         (Set as_refn$var $x body))

  rule (ReverseLetrecBinds (End) (End))
    => (End)

  rule (ReverseLetrecBinds (End) (LetrecBind id init binds))
    => (LetrecBind id init binds)

  rule (ReverseLetrecBinds (LetrecBind id init binds) reversed)
    => (ReverseLetrecBinds binds (LetrecBind id init reversed))


  (* Sanity Check: Make sure that Letrec has the same binding
     weather it's desugared in general (above), or for the specific
     case of two bindings (below). *)

  rule (Letrec (LetrecBind x a (LetrecBind y b (End))) body)
    => (Let (LetBind x (Void) (LetBind y (Void) (End)))
         (Let (LetBind @alpha a (LetBind @beta b (End)))
           (Set as_refn$x $alpha (Set as_refn$y $beta body))))


  (* Regular Let *)

  rule (Let binds body)
    => (DesugarLet binds body (End) (End))

  rule (DesugarLet (Bind x defn binds) body params args)
    => (DesugarLet binds body (AppendParam x params) (AppendArg defn args))

  rule (DesugarLet (End) body params args)
    => (Apply (Lambda params body) args)


  (* Named Let *)

  rule (NamedLet proc_id binds body)
    => (DesugarNamedLet proc_id binds body (End) (End))

  rule (DesugarNamedLet proc_id (End) body params args)
    => (Letrec
         (LetrecBind proc_id (Lambda params body) (End))
         (Apply as_refn$proc_id args))

  rule (DesugarNamedLet proc_id (NamedLetBind arg_id init_expr binds) body params args)
    => (DesugarNamedLet proc_id binds body (AppendParam arg_id params) (AppendArg init_expr args))


  (* Do *)

(* The obvious desugaring doesn't work, and infers (among other things)
   that the variables are bound in the `init` expressions. *)

(*
  rule (Do binds test commands)
    => (DesugarDo binds test commands (End) (End) (End))

  rule (DesugarDo (DoBind var init binds) test commands inits vars steps)
    => (DesugarDo binds test commands
         (AppendArg init inits)
         (AppendParam var vars)
         (AppendArg as_refn$var steps))

  rule (DesugarDo (DoBindStep var init step binds) test commands inits vars steps)
    => (DesugarDo binds test commands
         (AppendArg init inits)
         (AppendParam var vars)
         (AppendArg step steps))

  rule (DesugarDo (End) (DoTest test exprs) commands (Arg a inits) (Param b vars) (Arg c steps))
    => (Letrec (Bindrec @loop
         (Lambda (Param b vars)
           (If test
             (Begin (Void) exprs)
             (Begin commands (Apply $loop (Arg c steps))))))
         (Apply $loop (Arg a inits)))
*)


  (* Helpers *)
  
  rule (AppendParam param (End))
    => (Param param (End))

  rule (AppendParam new_param (Param param params))
    => (Param param (AppendParam new_param params))

  rule (AppendArg arg (End))
    => (Arg arg (End))

  rule (AppendArg new_arg (Arg arg args))
    => (Arg arg (AppendArg new_arg args))


}
